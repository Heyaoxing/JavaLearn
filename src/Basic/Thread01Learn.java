package Basic;

public class Thread01Learn extends Thread {
	/**
	 * 之所以多线程会出现锁和数据共享的问题，本质原因在于cpu
	 * 现代的cpu一边都是多核心来完成多任务，而在执行程序的过程中由于cpu执行的速度大于cpu读取内存信息的速度，为了解决读取速度带来的瓶颈问题，
	 * 每个cpu核心会有自己的一个高速缓存，在执行前先将所需执行的数据从内存读取一个副本到高速缓存中，cpu执行时直接从高速缓存读取和修改，完成执行后再刷新到主机内存
	 * 由于在多线程中，不同的线程可以运行在不同的cpu核心中，导致一个共享变量会缓存在不同核心的高速缓存中，在进行修改和刷新主机内存时，线程会将各自执行的结果更新到内存，导致结果不一致
	 * 使用锁机制时，可以阻塞住cpu总线访问限制指定的内存变量，保证在锁期间总线唯一访问改变量的权限
	 * cpu还有一个优化机制会影响多线程的结果：指令重排序。
	 * cpu在执行程序语句前会先分析各语句之间是否会相互依赖，在不相互依赖的情况下，cpu会将这些程序语句重新排列，导致多线程处理任务时会出现执行结果出现差异
	 * 因此，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。
	 * 
	 * 原子性操作是指一步到位对主机内存进行操作没有多余的步骤，或者是同一时刻保证只有一个线程在操作，比如使用同步锁synchronized或Lock
	 * 可见性是指一个共享变量被修改后能立即更新到内存，使用volatile修饰的共享变量能保证被及时刷新，并且通知其他缓存了该值的线程在高速缓存中此值无效，需要重新从主机内存中读取
	 */
	@Override
	public   void run() {
		Thread.currentThread().setPriority(6);
		for(int i=0;i<2000000;i++){
			if(Thread.interrupted()){  //调用interrupt()方法标记状态为中断
				System.out.println("中断线程");
				break;
			}
			System.out.println(i);
		}
		System.out.println("完成");
	}
}
